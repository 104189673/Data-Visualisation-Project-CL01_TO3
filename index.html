<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Radar Chart with Bubble Chart</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  body { font-family: Arial, sans-serif; }
  #controls { margin-bottom: 20px; }
  #radarChart { margin: 0 auto; }
  .tooltip {
    position: absolute;
    text-align: center;
    width: 60px;
    height: 28px;
    padding: 2px;
    font: 12px sans-serif;
    background: lightsteelblue;
    border: 0px;
    border-radius: 8px;
    pointer-events: none;
  }
  .legend {
    font-size: 12px;
  }
</style>
</head>
<body>
<h1>Data Visualization Project Website</h1>
<div id="controls">
  <label for="countrySelect">Country:</label>
  <select id="countrySelect"></select>
  <label for="yearSelect">Year:</label>
  <select id="yearSelect"></select>
  <label for="measureSelect">Type of Measure:</label>
  <select id="measureSelect">
    <option value="Number">Number</option>
    <option value="Per 100,000 population">Per 100,000 population</option>
  </select>
  <button id="addButton">ADD</button>
</div>
<!-- Radar Chart -->
<div id="radarChart"></div>
<div class="tooltip" id="tooltip" style="opacity: 0;"></div>

<script>
const categories = [
  'Medical graduates',
  'Dentists graduates',
  'Pharmacists graduates',
  'Midwives graduates',
  'Nursing graduates',
  'Professional nursing graduates',
  'Associate Professional nursing graduates'
];
const angleSlice = Math.PI * 2 / categories.length; // Calculates the angle to divide a circle into seven parts

const radarScale = d3.scaleLinear().domain([0, 10]).range([0, 300]);

const colorScale = d3.scaleOrdinal().range(['#E69F00', '#56B4E9', '#009E73', '#F0E442', '#0072B2', '#D55E00', '#CC79A7']);

const svg = d3.select("#radarChart")
  .append("svg")
  .attr("width", 1200)
  .attr("height", 900)
  .append("g")
  .attr("transform", "translate(600, 350)");

const tooltip = d3.select("#tooltip");

// Draw polygons for levels
for (let i = 1; i <= 5; i++) {
  const levelFactor = radarScale(i * 2);
  const levelData = categories.map((d, j) => ({
    x: levelFactor * Math.cos(angleSlice * j - Math.PI / 2),
    y: levelFactor * Math.sin(angleSlice * j - Math.PI / 2)
  }));

  svg.append("polygon")
    .attr("points", levelData.map(d => [d.x, d.y].join(",")).join(" "))
    .attr("stroke", "gray")
    .attr("stroke-width", 1)
    .attr("fill", "none")
    .attr("opacity", 0.3);
}

// Draw category labels
svg.selectAll(".category-label")
  .data(categories)
  .enter().append("text")
  .attr("class", "category-label")
  .attr("x", (d, i) => Math.cos(angleSlice * i - Math.PI / 2) * (radarScale(10) + 10))
  .attr("y", (d, i) => Math.sin(angleSlice * i - Math.PI / 2) * (radarScale(10) + 10))
  .text(d => d)
  .attr("text-anchor", (d, i) => (Math.cos(angleSlice * i - Math.PI / 2) < 0) ? "end" : "start")
  .attr("alignment-baseline", "middle");

// Function to update the radar chart
function updateRadarChart(data, countries) {
  // Clear previous radar lines and circles
  svg.selectAll(".radar-line").remove();
  svg.selectAll(".radar-circle").remove();

  // Find the maximum value for radar scale domain calculation
  let maxDataValue = 0;
  countries.forEach(country => {
    const values = data[country].map(d => parseFloat(d['Percentage of graduates contributed by country']));
    const maxValueInCountry = d3.max(values);
    if (maxValueInCountry > maxDataValue) {
      maxDataValue = maxValueInCountry;
    }
  });

  // Recalculate radar scale domain based on the maximum value
  radarScale.domain([0, maxDataValue]);

  // Draw radar lines (polygons) for all countries first
  countries.forEach((country, index) => {
    const values = data[country].map(d => parseFloat(d['Percentage of graduates contributed by country']));

    svg.append("polygon")
      .datum(values)
      .attr("class", "radar-line")
      .attr("points", values.map((d, i) => [
        radarScale(d) * Math.cos(angleSlice * i - Math.PI / 2),
        radarScale(d) * Math.sin(angleSlice * i - Math.PI / 2)
      ].join(",")).join(" "))
      .attr("stroke", colorScale(index))
      .attr("stroke-width", 2)
      .attr("fill", colorScale(index))
      .attr("fill-opacity", 0.1);
  });

  // Draw circles for data points on top of radar lines for all countries
  countries.forEach((country, index) => {
    const values = data[country].map(d => parseFloat(d['Percentage of graduates contributed by country']));

    values.forEach((d, i) => {
      if (d !== 0) { // Skip adding point at the center
        svg.append("circle")
          .attr("class", "radar-circle")
          .attr("cx", radarScale(d) * Math.cos(angleSlice * i - Math.PI / 2))
          .attr("cy", radarScale(d) * Math.sin(angleSlice * i - Math.PI / 2))
          .attr("r", 4)
          .attr("fill", colorScale(index))
          .on("mouseover", function(event) {
            tooltip.transition().duration(200).style("opacity", .9);
            tooltip.html(d)
              .style("left", (event.pageX + 5) + "px")
              .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", function() {
            tooltip.transition().duration(500).style("opacity", 0);
          });
      }
    });
  });

  // Add legend
  svg.selectAll(".legend").remove();
  const legend = svg.append("g")
    .attr("class", "legend")
    .attr("transform", "translate(-350, -300)");

  legend.selectAll("rect")
    .data(countries)
    .enter().append("rect")
    .attr("x", 0)
    .attr("y", (d, i) => i * 20)
    .attr("width", 18)
    .attr("height", 18)
    .style("fill", (d, i) => colorScale(i));

  legend.selectAll("text")
    .data(countries)
    .enter().append("text")
    .attr("x", 24)
    .attr("y", (d, i) => i * 20 + 9)
    .attr("dy", ".35em")
    .text(d => d);
}

// Load the data and initialize the dropdowns
d3.csv("Secondary Filtered Dataset.csv").then(data => {
  const filteredData = data.filter(d => categories.includes(d.Variable));
  const countries = Array.from(new Set(filteredData.map(d => d.Country)));
  const years = Array.from(new Set(filteredData.map(d => d.Year)));
  const measures = Array.from(new Set(filteredData.map(d => d.Measure)));

  // Populate the country dropdown
  const countrySelect = d3.select("#countrySelect");
  countrySelect.selectAll("option")
    .data(countries)
    .enter().append("option")
    .text(d => d);

  // Populate the year dropdown
  const yearSelect = d3.select("#yearSelect");
  yearSelect.selectAll("option")
    .data(years)
    .enter().append("option")
    .text(d => d);

  // Populate the measure dropdown
  const measureSelect = d3.select("#measureSelect");
  measureSelect.selectAll("option")
    .data(measures)
    .enter().append("option")
    .text(d => d);

  // Initialize selected data
  let selectedData = {};
  let selectedCountries = [];

  // Function to add data for the selected country and year
  function addCountryData() {
    const selectedCountry = countrySelect.node().value;
    const selectedYear = yearSelect.node().value;
    const selectedMeasure = measureSelect.node().value;
    if (!selectedCountries.includes(selectedCountry)) {
      selectedCountries.push(selectedCountry);
      selectedData[selectedCountry] = filteredData.filter(d => 
        d.Country === selectedCountry && 
        d.Year === selectedYear && 
        d.Measure === selectedMeasure
      );
      updateRadarChart(selectedData, selectedCountries);
    }
  }

  // Add button event listener
  d3.select("#addButton").on("click", addCountryData);
});
</script>

</body>
</html>